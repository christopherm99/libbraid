libbraid -- ANSI C library for coroutines.

WHAT

  libbraid is heavily inspired by higan's libco and Russ Cox's libtask.

  The goal is to provide the non-blocking IO features of libtask, while keeping
  the simplicity of libco. Additionally, libbraid should be highly portable,
  just by writing a bit of assembly for saving and restoring contexts (and some
  glue in `createctx`).

TERMINOLOGY

 * braid: a set of cooperatively scheduled cords.
 * cord: a coroutine.
 * context: a set of registers and stack that can be switched to.

USAGE

  libbraid provides two APIs: the low-level context switching API and a
  higher-level cooperative scheduling API. The low-level API can be accessed
  through `ctx.h`, which provides the following functions:

    ctx_t   newctx(void);

            Creates a new, empty context.

    ctx_t   createctx(void (*f)(usize), usize stacksize, usize arg);

            Creates a new context with entry point `f` and stack size
            `stacksize`. When switching to this context, `arg` will be passed.

    void    swapctx(ctx_t *old, ctx_t new);

            Swaps to the context `new`. The current context is saved in `old`.
            Use `newctx` to create the first `old` context.

  The higher-level API is available through `braid.h`, which provides the
  following functions:

    braid_t braidinit(void);

            Creates a new, uninitialized braid.

    void    braidadd(braid_t b, void (*f)(braid_t, usize), usize stacksize,
                     const char *name, uchar flags, usize arg);

            Adds a new cord to the braid with entry point `f` and stack size
            `stacksize`. The cord will be scheduled cooperatively with other
            cords in the braid. The argument `b` will be passed to `f`, along
            with `arg`. The `name` argument is nullable, and used for debuging
            (compile with `-DEBUG`. The `flags` arguemtn sets the type of cord
            that is being created:

              * CORD_NORMAL: a normal cord.
              * CORD_SYSTEM: ignored when deciding the braid size.

    void    braidstart(braid_t b);

            Launches the braid scheduler, which continues executing until all
            cords have exited.

    void    braidyield(braid_t b);

            Called by a cord, yielding control back to the braid scheduler.

    usize   braidblock(braid_t b);

            Called by a cord to block itself. The cord will not be scheduled
            again until it is added back to the braid with `braidunblock`.
            The return value is determined by the how the cord was added back
            to the braid (see `braiunblock`).

    void    braidunblock(braid_t b, cord_t c, usize val);

            Adds an existing cord `c` to the braid `b`. This function is mostly
            used for plumbing blocking operations (see `braidblock`). If this
            cord was stopped by `braidblock`, `val` is the value that will be
            returned from the `braidblock` call.

    void    braidexit(braid_t b);

            Called by a cord to exit the braid. The cord will be removed from the
            braid and will not be scheduled again. If the braid size is now 0,
            will cause braidlaunch to return.

    cord_t  braidcurr(braid_t b);

            Returns the currently scheduled cord in the braid `b`.

    uint    braidcnt(braid_t b);

            Returns the number of (non-system) scheduled cords in the braid `b`.

    void  **braiddata(braid_t b, uchar key);

            Returns a pointer to braid-shared storage for the given key. If the
            key is not already present, a new pointer will be allocated.

            NB: the non-blocking IO API stores data under the key 0xFD and the
            channel API stores data under the key 0xFC. Thusly, if you use any
            of these APIs, do not use their keys for your own data.

  Non-blocking IO is available through `fd.h`.

    void    fdvisor(braid_t b, usize _);

            This function should be installed as a system cord into any braid
            using non-blocking IO. The argument `_` is ignored.

    short   fdpoll(braid_t b, int fd, short events);

            Yields the current cord until one of the specified events (or error
            events) occurs on the file descriptor `fd`. The `events` argument
            is the same as in `poll(2)`, as is the return value.

    int     fdread(braid_t b, int fd, void *buf, size_t count);

            Yields the current cord until `poll(2)` indicates that the file
            descriptor `fd` is ready for reading, then performs a `read(2)`.

    int     fdwrite(braid_t b, int fd, const void *buf, size_t count);

            Yields the current cord until `poll(2)` indicates that the file
            descriptor `fd` is ready for writing, then performs a `write(2)`.

  Go-style (unbuffered) channels are available through `ch.h`.

    void    chvisor(braid_t b, usize _);

            This function should be installed as a system cord into any braid
            using channels. The argument `_` is ignored.

    ch_t    chcreate(braid_t b);

            Creeates a new channel in the braid `b`.

    void    chdestroy(braid_t b, ch_t ch);

            Destroys the channel `ch` in the braid `b`. All pending sends return
            failed and all pending receives return 0.

    uint    chsend(braid_t b, ch_t ch, usize data);

            Sends `data` to the channel `ch` in the braid `b`, blocking until
            the data is received. Returns 0 on success, or 1 if the channel was
            destroyed.

    usize   chrecv(braid_t b, ch_t ch);

            Receives data from the channel `ch` in the braid `b`, blocking until
            data is available. Returns the received data, or 0 if the channel was
            destroyed.

